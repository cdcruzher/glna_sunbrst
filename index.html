<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taxonomy Sunburst Visualizer</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .chart-container path { cursor: pointer; transition: opacity 0.3s; }
        .chart-container path:hover { opacity: 0.8; }
        
        /* Pulse animation for the found match */
        @keyframes pulse-stroke {
            0% { stroke-width: 2px; stroke: #ef4444; stroke-opacity: 0.5; }
            50% { stroke-width: 6px; stroke: #ef4444; stroke-opacity: 1; }
            100% { stroke-width: 2px; stroke: #ef4444; stroke-opacity: 0.5; }
        }
        .highlighted-arc {
            animation: pulse-stroke 2s infinite;
            stroke: #ef4444 !important;
            stroke-opacity: 1 !important;
            z-index: 50;
        }
        
        .chart-label { pointer-events: none; font-size: 10px; fill: #333; text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff; }
        
        /* Custom scrollbar for table */
        .custom-scroll::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scroll::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

    const { useState, useEffect, useRef, useMemo } = React;

    // --- Similarity Logic (K-mer Jaccard) ---
    
    const getKmers = (sequence, k = 6) => {
        const kmers = new Set();
        if (!sequence || sequence.length < k) return kmers;
        for (let i = 0; i < sequence.length - k + 1; i++) {
            kmers.add(sequence.substring(i, i + k));
        }
        return kmers;
    };

    const calculateSimilarity = (seq1, seq2) => {
        const k = 6; 
        const set1 = getKmers(seq1, k);
        const set2 = getKmers(seq2, k);

        if (set1.size === 0 || set2.size === 0) return 0;

        let intersection = 0;
        for (const kmer of set1) {
            if (set2.has(kmer)) intersection++;
        }

        const union = set1.size + set2.size - intersection;
        return intersection / union;
    };


    // --- Advanced Taxonomy Logic ---

    const genusDatabase = {
        // --- BACTERIA ---
        "Escherichia": { k: "Bacteria", p: "Proteobacteria", f: "Enterobacteriaceae" },
        "Salmonella": { k: "Bacteria", p: "Proteobacteria", f: "Enterobacteriaceae" },
        "Vibrio": { k: "Bacteria", p: "Proteobacteria", f: "Vibrionaceae" },
        "Pseudomonas": { k: "Bacteria", p: "Proteobacteria", f: "Pseudomonadaceae" },
        "Yersinia": { k: "Bacteria", p: "Proteobacteria", f: "Yersiniaceae" },
        "Wolbachia": { k: "Bacteria", p: "Proteobacteria", f: "Anaplasmataceae" },
        "Rickettsia": { k: "Bacteria", p: "Proteobacteria", f: "Rickettsiaceae" },
        "Neisseria": { k: "Bacteria", p: "Proteobacteria", f: "Neisseriaceae" },
        "Legionella": { k: "Bacteria", p: "Proteobacteria", f: "Legionellaceae" },
        "Helicobacter": { k: "Bacteria", p: "Campylobacterota", f: "Helicobacteraceae" },
        "Campylobacter": { k: "Bacteria", p: "Campylobacterota", f: "Campylobacteraceae" },
        "Caulobacter": { k: "Bacteria", p: "Proteobacteria", f: "Caulobacteraceae" },
        "Rhizobium": { k: "Bacteria", p: "Proteobacteria", f: "Rhizobiaceae" },
        "Agrobacterium": { k: "Bacteria", p: "Proteobacteria", f: "Rhizobiaceae" },
        "Staphylococcus": { k: "Bacteria", p: "Firmicutes", f: "Staphylococcaceae" },
        "Bacillus": { k: "Bacteria", p: "Firmicutes", f: "Bacillaceae" },
        "Streptococcus": { k: "Bacteria", p: "Firmicutes", f: "Streptococcaceae" },
        "Lactobacillus": { k: "Bacteria", p: "Firmicutes", f: "Lactobacillaceae" },
        "Listeria": { k: "Bacteria", p: "Firmicutes", f: "Listeriaceae" },
        "Clostridium": { k: "Bacteria", p: "Firmicutes", f: "Clostridiaceae" },
        "Enterococcus": { k: "Bacteria", p: "Firmicutes", f: "Enterococcaceae" },
        "Mycobacterium": { k: "Bacteria", p: "Actinobacteria", f: "Mycobacteriaceae" },
        "Streptomyces": { k: "Bacteria", p: "Actinobacteria", f: "Streptomycetaceae" },
        "Corynebacterium": { k: "Bacteria", p: "Actinobacteria", f: "Corynebacteriaceae" },
        "Frankia": { k: "Bacteria", p: "Actinobacteria", f: "Frankiaceae" },
        "Prochlorococcus": { k: "Bacteria", p: "Cyanobacteria", f: "Prochlorococcaceae" },
        "Synechococcus": { k: "Bacteria", p: "Cyanobacteria", f: "Synechococcaceae" },
        "Nostoc": { k: "Bacteria", p: "Cyanobacteria", f: "Nostocaceae" },
        "Anabaena": { k: "Bacteria", p: "Cyanobacteria", f: "Nostocaceae" },
        "Bacteroides": { k: "Bacteria", p: "Bacteroidetes", f: "Bacteroidaceae" },
        "Chlamydia": { k: "Bacteria", p: "Chlamydiae", f: "Chlamydiaceae" },
        "Borrelia": { k: "Bacteria", p: "Spirochaetes", f: "Borreliaceae" },
        "Treponema": { k: "Bacteria", p: "Spirochaetes", f: "Spirochaetaceae" },
        "Lactococcus": { k: "Bacteria", p: "Firmicutes", f: "Streptococcaceae" },
        "Gloeocapsa": { k: "Bacteria", p: "Cyanobacteria", f: "Chroococcaceae" },
        "Pleurocapsa": { k: "Bacteria", p: "Cyanobacteria", f: "Pleurocapsaceae" },
        "Cyanothece": { k: "Bacteria", p: "Cyanobacteria", f: "Chroococcaceae" },
        "Geminocystis": { k: "Bacteria", p: "Cyanobacteria", f: "Chroococcaceae" },
        "Stanieria": { k: "Bacteria", p: "Cyanobacteria", f: "Dermocarpellaceae" },
        "Leptolyngbya": { k: "Bacteria", p: "Cyanobacteria", f: "Leptolyngbyaceae" },
        "Oscillatoria": { k: "Bacteria", p: "Cyanobacteria", f: "Oscillatoriaceae" },
        "Microcoleus": { k: "Bacteria", p: "Cyanobacteria", f: "Oscillatoriaceae" },
        "Phormidium": { k: "Bacteria", p: "Cyanobacteria", f: "Oscillatoriaceae" },
        "Trichodesmium": { k: "Bacteria", p: "Cyanobacteria", f: "Oscillatoriaceae" },
        "Limnothrix": { k: "Bacteria", p: "Cyanobacteria", f: "Pseudanabaenaceae" },
        "Pseudanabaena": { k: "Bacteria", p: "Cyanobacteria", f: "Pseudanabaenaceae" },
        "Geitlerinema": { k: "Bacteria", p: "Cyanobacteria", f: "Pseudanabaenaceae" },
        "Synechocystis": { k: "Bacteria", p: "Cyanobacteria", f: "Chroococcaceae" },
        "Thermosynechococcus": { k: "Bacteria", p: "Cyanobacteria", f: "Synechococcaceae" },
        "Acaryochloris": { k: "Bacteria", p: "Cyanobacteria", f: "Acaryochloridaceae" },
        "Arthrospira": { k: "Bacteria", p: "Cyanobacteria", f: "Microcoleaceae" },
        "Lyngbya": { k: "Bacteria", p: "Cyanobacteria", f: "Oscillatoriaceae" },

        // --- ARCHAEA ---
        "Methanocaldococcus": { k: "Archaea", p: "Euryarchaeota", f: "Methanocaldococcaceae" },
        "Methanosarcina": { k: "Archaea", p: "Euryarchaeota", f: "Methanosarcinaceae" },
        "Halobacterium": { k: "Archaea", p: "Euryarchaeota", f: "Halobacteriaceae" },
        "Sulfolobus": { k: "Archaea", p: "Crenarchaeota", f: "Sulfolobaceae" },
        "Pyrococcus": { k: "Archaea", p: "Euryarchaeota", f: "Thermococcaceae" },

        // --- FUNGI ---
        "Saccharomyces": { k: "Fungi", p: "Ascomycota", f: "Saccharomycetaceae" },
        "Candida": { k: "Fungi", p: "Ascomycota", f: "Saccharomycetaceae" },
        "Aspergillus": { k: "Fungi", p: "Ascomycota", f: "Aspergillaceae" },
        "Penicillium": { k: "Fungi", p: "Ascomycota", f: "Aspergillaceae" },
        "Fusarium": { k: "Fungi", p: "Ascomycota", f: "Nectriaceae" },
        "Neurospora": { k: "Fungi", p: "Ascomycota", f: "Sordariaceae" },
        "Cryptococcus": { k: "Fungi", p: "Basidiomycota", f: "Tremellaceae" },
        "Ustilago": { k: "Fungi", p: "Basidiomycota", f: "Ustilaginaceae" },
        "Agaricus": { k: "Fungi", p: "Basidiomycota", f: "Agaricaceae" },

        // --- PLANTS ---
        "Arabidopsis": { k: "Plantae", p: "Tracheophyta", f: "Brassicaceae" },
        "Zea": { k: "Plantae", p: "Tracheophyta", f: "Poaceae" }, 
        "Oryza": { k: "Plantae", p: "Tracheophyta", f: "Poaceae" }, 
        "Triticum": { k: "Plantae", p: "Tracheophyta", f: "Poaceae" },
        "Solanum": { k: "Plantae", p: "Tracheophyta", f: "Solanaceae" }, 
        "Nicotiana": { k: "Plantae", p: "Tracheophyta", f: "Solanaceae" },
        "Glycine": { k: "Plantae", p: "Tracheophyta", f: "Fabaceae" },
        "Medicago": { k: "Plantae", p: "Tracheophyta", f: "Fabaceae" },
        "Vitis": { k: "Plantae", p: "Tracheophyta", f: "Vitaceae" }, 

        // --- ANIMALS ---
        "Homo": { k: "Animalia", p: "Chordata", f: "Hominidae" },
        "Mus": { k: "Animalia", p: "Chordata", f: "Muridae" }, 
        "Rattus": { k: "Animalia", p: "Chordata", f: "Muridae" }, 
        "Canis": { k: "Animalia", p: "Chordata", f: "Canidae" },
        "Felis": { k: "Animalia", p: "Chordata", f: "Felidae" },
        "Bos": { k: "Animalia", p: "Chordata", f: "Bovidae" }, 
        "Sus": { k: "Animalia", p: "Chordata", f: "Suidae" }, 
        "Gallus": { k: "Animalia", p: "Chordata", f: "Phasianidae" }, 
        "Danio": { k: "Animalia", p: "Chordata", f: "Cyprinidae" }, 
        "Xenopus": { k: "Animalia", p: "Chordata", f: "Pipidae" }, 
        "Drosophila": { k: "Animalia", p: "Arthropoda", f: "Drosophilidae" },
        "Caenorhabditis": { k: "Animalia", p: "Nematoda", f: "Rhabditidae" },
        "Aquila": { k: "Animalia", p: "Chordata", f: "Accipitridae" }, // Added from file
        "Spizaetus": { k: "Animalia", p: "Chordata", f: "Accipitridae" }, // Added from file
        "Labeo": { k: "Animalia", p: "Chordata", f: "Cyprinidae" }, // Added from file
        
        // --- VIRUSES ---
        "Enterobacteria": { k: "Viruses", p: "Phage", f: "Caudovirales" }, 
        "Lactococcus": { k: "Viruses", p: "Phage", f: "Caudovirales" }, 
        "Synechococcus": { k: "Viruses", p: "Phage", f: "Myoviridae" }, 
        "T4": { k: "Viruses", p: "Phage", f: "Myoviridae" },
        "Lambda": { k: "Viruses", p: "Phage", f: "Siphoviridae" },
        "HIV": { k: "Viruses", p: "Retroviridae", f: "Lentivirus" },
        "Influenza": { k: "Viruses", p: "Orthomyxoviridae", f: "Betainfluenzavirus" },
        "Coronavirus": { k: "Viruses", p: "Riboviria", f: "Coronaviridae" },
        "Sars-cov-2": { k: "Viruses", p: "Riboviria", f: "Coronaviridae" },
        "Bacteriophage": { k: "Viruses", p: "Phage", f: "Unclassified" },
        "Pelagibacter": { k: "Viruses", p: "Phage", f: "Unclassified" }, // Context dependent fix
        "Methylophilales": { k: "Viruses", p: "Phage", f: "Unclassified" } // Context dependent
    };

    const fallbackRules = [
        { pattern: /metagenome/i, k: "Environmental", p: "Metagenome", f: "Unclassified" },
        { pattern: /riboswitch/i, k: "Other", p: "RNA Structure", f: "Riboswitch" },
        { pattern: /mitochondri/i, k: "Eukaryota", p: "Organelle", f: "Mitochondria" },
        { pattern: /chloroplast/i, k: "Plantae", p: "Organelle", f: "Chloroplast" },
        { pattern: /plasmid/i, k: "Bacteria", p: "Plasmid", f: "Unclassified" },
        { pattern: /cyanobacter/i, k: "Bacteria", p: "Cyanobacteria", f: "Unclassified" },
        { pattern: /proteobacter/i, k: "Bacteria", p: "Proteobacteria", f: "Unclassified" },
        { pattern: /firmicutes/i, k: "Bacteria", p: "Firmicutes", f: "Unclassified" },
        { pattern: /bacteroid/i, k: "Bacteria", p: "Bacteroidetes", f: "Unclassified" },
        { pattern: /actinobacter/i, k: "Bacteria", p: "Actinobacteria", f: "Unclassified" },
        { pattern: /mycoplasma/i, k: "Bacteria", p: "Tenericutes", f: "Mycoplasmataceae" },
        { pattern: /bacter/i, k: "Bacteria", p: "Unclassified", f: "Unclassified" },
        { pattern: /euryarchaeota/i, k: "Archaea", p: "Euryarchaeota", f: "Unclassified" },
        { pattern: /crenarchaeota/i, k: "Archaea", p: "Crenarchaeota", f: "Unclassified" },
        { pattern: /archae/i, k: "Archaea", p: "Unclassified", f: "Unclassified" },
        { pattern: /phage/i, k: "Viruses", p: "Phage", f: "Bacteriophage" },
        { pattern: /virus|viridae/i, k: "Viruses", p: "Unclassified", f: "Unclassified" },
        { pattern: /fungi|mycota|yeast/i, k: "Fungi", p: "Unclassified", f: "Unclassified" },
        { pattern: /plant|chloroplast/i, k: "Plantae", p: "Unclassified", f: "Unclassified" },
        { pattern: /animal|metazoa|mammal/i, k: "Animalia", p: "Unclassified", f: "Unclassified" },
        { pattern: /human/i, k: "Animalia", p: "Chordata", f: "Hominidae" }
    ];

    const cleanWord = (word) => word.replace(/[^a-zA-Z0-9-]/g, '');

    const lookupGenus = (word) => {
        if(!word || word.length < 3) return null; 
        const genusCandidate = cleanWord(word);
        let genusKey = genusCandidate.charAt(0).toUpperCase() + genusCandidate.slice(1).toLowerCase();
        if (genusDatabase[genusKey]) {
            return { ...genusDatabase[genusKey], genus: genusKey };
        }
        return null;
    };

    // --- Parsing Logic ---

    const parseFasta = (text) => {
        if (!text) return [];
        
        const entries = text.split('>').filter(entry => entry.trim().length > 0);
        
        const parsedData = entries.map(entry => {
            const firstNewLine = entry.indexOf('\n');
            let fullHeader = '';
            let sequence = '';

            if (firstNewLine === -1) {
                fullHeader = entry.trim();
            } else {
                fullHeader = entry.substring(0, firstNewLine).trim();
                sequence = entry.substring(firstNewLine).replace(/\s/g, ''); 
            }

            const tokens = fullHeader.split(/[\s|,\/\t]+/).filter(t => t.length > 0);
            
            let tax = null;
            let foundIndex = -1;

            // 1. Scan for a known Genus in the database
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].match(/subsp|str\.|strain|isolate/i)) continue;

                const match = lookupGenus(tokens[i]);
                if (match) {
                    tax = match;
                    foundIndex = i;
                    break; 
                }
            }

            // 2. CONTEXT AWARE FIX: 
            // If the header mentions "phage" or "virus", force classification to Virus.
            // This handles cases like "Synechococcus phage" -> Virus, "Pelagibacter phage" -> Virus.
            const headerLower = fullHeader.toLowerCase();
            const isViral = headerLower.includes("phage") || headerLower.includes("virus");

            if (isViral) {
                // If we found a genus (e.g., Synechococcus) but it's a phage
                if (tax) {
                    tax = {
                        k: "Viruses",
                        p: "Phage",
                        f: "Bacteriophage",
                        genus: tax.genus + " phage" 
                    };
                } else {
                    // No genus found, but it is a virus/phage
                    tax = {
                        k: "Viruses",
                        p: "Phage",
                        f: "Bacteriophage",
                        genus: "Unclassified Phage"
                    };
                }
            }

            // 3. Fallback Regex
            if (!tax) {
                for (let rule of fallbackRules) {
                    if (rule.pattern.test(fullHeader)) {
                        tax = rule;
                        break;
                    }
                }
            }
            
            if (!tax) {
                tax = { k: "Other", p: "Unclassified", f: "Unclassified" };
            }

            const hierarchy = [tax.k, tax.p, tax.f];
            
            if (tax.genus) {
                hierarchy.push(tax.genus);
                // Try to add species detail if we found a genus index
                if (foundIndex !== -1 && foundIndex + 1 < tokens.length) {
                    const potentialSpecies = tokens[foundIndex + 1];
                    if (!/^\d+$/.test(potentialSpecies) && !potentialSpecies.includes('=') && !isViral) {
                        hierarchy.push(tax.genus + " " + potentialSpecies);
                    } else if (isViral) {
                        // For viruses, just keep the genus level or add the next token if it looks like an ID
                        hierarchy.push(tax.genus);
                    } else {
                         hierarchy.push(tax.genus + " sp.");
                    }
                } else {
                    hierarchy.push(tax.genus + (isViral ? "" : " sp."));
                }
            } else {
                // If regex matched or unknown
                // Clean tokens for display
                const cleanTokens = tokens.filter(t => !/^\d+$/.test(t) && t.length > 3).slice(0, 2);
                if (cleanTokens.length > 0) {
                    hierarchy.push(cleanTokens.join(" "));
                } else {
                    hierarchy.push("Unknown Entry");
                }
            }

            return {
                header: fullHeader,
                sequence: sequence, 
                length: sequence.length,
                taxonomy: hierarchy.filter(t => t && t !== "Unknown" && t !== "Unclassified")
            };
        });

        return parsedData;
    };

    const buildHierarchy = (data, weightBy = 'count') => {
        const root = { name: "Life", children: [], entries: [] };

        data.forEach(item => {
            let currentNode = root;
            if (!currentNode.entries) currentNode.entries = [];
            currentNode.entries.push(item);
            
            const levels = item.taxonomy;

            levels.forEach((token, index) => {
                let child = currentNode.children.find(c => c.name === token);
                if (!child) {
                    child = { name: token, children: [], entries: [] };
                    currentNode.children.push(child);
                }
                child.entries.push(item);
                currentNode = child;
            });

            if (!currentNode.value) currentNode.value = 0;
            currentNode.value += (weightBy === 'count' ? 1 : item.length);
            
            if (!currentNode.sequences) currentNode.sequences = 0;
            currentNode.sequences += 1;
        });

        return root;
    };

    // --- Visualization ---

    const Sunburst = ({ data, scale = 100, onNodeClick, highlightedPath, zoomToPath }) => {
        const svgRef = useRef(null);
        const logicalWidth = 1200;
        const logicalHeight = 1200;

        useEffect(() => {
            if (!data || !svgRef.current) return;

            d3.select(svgRef.current).selectAll("*").remove();

            const radius = logicalWidth / 6;
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
            
            const hierarchy = d3.hierarchy(data)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);

            const root = d3.partition()
                .size([2 * Math.PI, hierarchy.height + 1])
                (hierarchy);

            root.each(d => d.current = d);

            const arc = d3.arc()
                .startAngle(d => d.x0)
                .endAngle(d => d.x1)
                .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                .padRadius(radius * 1.5)
                .innerRadius(d => d.y0 * radius)
                .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1));

            const svg = d3.select(svgRef.current)
                .attr("viewBox", [-logicalWidth / 2, -logicalHeight / 2, logicalWidth, logicalHeight])
                .style("font", "14px sans-serif");

            const centerGroup = svg.append("g").attr("pointer-events", "none");
            const centerText = centerGroup.append("text")
                .attr("text-anchor", "middle")
                .style("fill", "#555")
                .style("font-weight", "bold");
            
            centerText.append("tspan").attr("class", "center-name").attr("x", 0).attr("dy", "-0.5em").style("font-size", "18px").text("Life");
            centerText.append("tspan").attr("class", "center-val").attr("x", 0).attr("dy", "1.4em").style("font-size", "14px").style("fill", "#888").text("");

            let focus = root;

            const isHighlighted = (d) => {
                if (!highlightedPath) return false;
                const nodePath = d.ancestors().map(n => n.data.name).reverse().slice(1); 
                if (nodePath.join("|") === highlightedPath.join("|")) return true;
                return false;
            };

            const path = svg.append("g")
                .selectAll("path")
                .data(root.descendants().slice(1))
                .join("path")
                .attr("class", d => isHighlighted(d) ? "highlighted-arc" : "")
                .attr("fill", d => {
                    let ancestor = d;
                    while (ancestor.depth > 1) ancestor = ancestor.parent;
                    return colorScale(ancestor.data.name);
                })
                .attr("fill-opacity", d => {
                    if (highlightedPath && !isHighlighted(d)) {
                         return d.children ? 0.4 : 0.2; 
                    }
                    return d.children ? 0.8 : 0.6;
                })
                .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")
                .attr("d", d => arc(d.current));

            path.filter(d => d.children)
                .style("cursor", "pointer")
                .on("click", clicked);

            path.append("title")
                .text(d => `${d.ancestors().map(d => d.data.name).reverse().join(" > ")}\nValue: ${d.value.toLocaleString()}`);

            const label = svg.append("g")
                .attr("pointer-events", "none")
                .attr("text-anchor", "middle")
                .style("user-select", "none")
                .selectAll("text")
                .data(root.descendants().slice(1))
                .join("text")
                .attr("dy", "0.35em")
                .attr("fill-opacity", d => +labelVisible(d.current))
                .attr("transform", d => labelTransform(d.current))
                .attr("class", "chart-label")
                .style("font-size", "11px")
                .text(d => d.data.name);

            path.on("mouseover", function(event, d) {
                if (!highlightedPath) {
                    path.style("opacity", 0.3);
                    const sequence = d.ancestors().reverse();
                    path.filter(node => sequence.indexOf(node) >= 0)
                        .style("opacity", 1).style("stroke", "#000").style("stroke-width", "1px");
                }
                d3.select(".center-name").text(d.data.name);
                d3.select(".center-val").text(d.value.toLocaleString());
            })
            .on("mouseout", function() {
                if (!highlightedPath) {
                    path.style("opacity", 1).style("stroke", "none");
                }
                d3.select(".center-name").text(focus.data.name);
                d3.select(".center-val").text("");
            });

            const parent = svg.append("circle")
                .datum(root)
                .attr("r", radius)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("click", clicked);

            function clicked(event, p) {
                if (event && onNodeClick) {
                    onNodeClick(p.data);
                }

                focus = p;
                d3.select(".center-name").text(p.data.name);
                d3.select(".center-val").text("");

                parent.datum(p.parent || root);

                root.each(d => d.target = {
                    x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                    x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                    y0: Math.max(0, d.y0 - p.depth),
                    y1: Math.max(0, d.y1 - p.depth)
                });

                const t = svg.transition().duration(750);

                path.transition(t)
                    .tween("data", d => {
                        const i = d3.interpolate(d.current, d.target);
                        return t => d.current = i(t);
                    })
                    .filter(function(d) {
                        return +this.getAttribute("fill-opacity") || arcVisible(d.target);
                    })
                    .attr("fill-opacity", d => {
                        const visible = arcVisible(d.target);
                        if (!visible) return 0;
                        if (highlightedPath && !isHighlighted(d)) return d.children ? 0.4 : 0.2;
                        return d.children ? 0.8 : 0.6;
                    })
                    .attr("class", d => isHighlighted(d) ? "highlighted-arc" : "")
                    .attr("pointer-events", d => arcVisible(d.target) ? "auto" : "none")
                    .attrTween("d", d => () => arc(d.current));

                label.filter(function(d) {
                    return +this.getAttribute("fill-opacity") || labelVisible(d.target);
                }).transition(t)
                    .attr("fill-opacity", d => +labelVisible(d.target))
                    .attrTween("transform", d => () => labelTransform(d.current));
            }

            if (zoomToPath) {
                const targetNode = root.descendants().find(d => {
                    const nodePath = d.ancestors().map(n => n.data.name).reverse().slice(1);
                    return nodePath.join("|") === zoomToPath.join("|");
                });
                
                if (targetNode) {
                    clicked(null, targetNode);
                    if(onNodeClick) onNodeClick(targetNode.data);
                }
            }

            function arcVisible(d) { return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0; }
            function labelVisible(d) { return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03; }
            function labelTransform(d) {
                const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
                const y = (d.y0 + d.y1) / 2 * radius;
                return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
            }

        }, [data, highlightedPath, zoomToPath]);

        return (
            <div className="relative flex justify-center items-center" style={{ width: '100%', height: '100%', overflow: 'auto' }}>
               <svg ref={svgRef} 
                    className="shadow-sm rounded-full bg-white"
                    style={{ width: `${scale}%`, height: 'auto', maxWidth: 'none', transition: 'width 0.3s ease' }}
               ></svg>
            </div>
        );
    };

    const App = () => {
        const [textInput, setTextInput] = useState('');
        const [parsedRawData, setParsedRawData] = useState([]);
        const [parsedData, setParsedData] = useState(null);
        const [weightBy, setWeightBy] = useState('count');
        const [chartSize, setChartSize] = useState(90); 
        const [isDragging, setIsDragging] = useState(false);
        const [loading, setLoading] = useState(false);
        const [selectedNode, setSelectedNode] = useState(null);

        const [querySequence, setQuerySequence] = useState('');
        const [matchResult, setMatchResult] = useState(null);
        const [highlightedPath, setHighlightedPath] = useState(null);
        const [zoomToPath, setZoomToPath] = useState(null);

        const exampleData = `>CYANO01 Prochlorococcus marinus subsp. pastoris str. CCMP1986
ATCGTTCATCTTCGAAAGAAGACGGAAGTAAGCGAAAGCTGAAGGAACGCGGC
>PROTEO01 Escherichia coli str. K-12 substr. MG1655
ATCGTTCATCCCTTTGGGGACGGAAGTAAGCGAAAGCTGAAGGAACGCGCA
>PROTEO02 Pseudomonas aeruginosa PAO1
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCT
>FIRMI01 Staphylococcus aureus subsp. aureus NCTC 8325
AACGTTCATCCCTTAGGGGACGGAAGTAGTCATAAGACGAAGGAACGCATT
>FIRMI02 Bacillus subtilis subsp. subtilis str. 168
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
>ARCH01 Methanocaldococcus jannaschii DSM 2661
ATCGTTCATCTCCATATCGGAGACGGAAGTAGGAAAAAATTCCGAAGGAACGCGCC
>FUNGI01 Saccharomyces cerevisiae S288C
GGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGC
>FUNGI02 Aspergillus niger strain A10
CCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
>VIRUS01 Enterobacteria phage T4
TTAATATATATATATATATATATATATATATATATATATATATATATATA
>PLANT01 Arabidopsis thaliana chromosome 1
CGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCG
>ANIMAL01 Homo sapiens chromosome 19 partial
AAAAAAAAAAAACCCCCCCCCCCCGGGGGGGGGGGGTTTTTTTTTTTTTT
>gi|12345|ref|NC_0000| Yersinia pestis CO92
ATATATATATATATATATATAT
>Mitochondria Mus musculus partial
CCCCCCCCCCCCCCCCCCCCCCCC
>Unknown Plasmid pBR322
GGGGGGGGGGGGGGGGGGGGGGGG`;

        useEffect(() => {
            setTextInput(exampleData);
        }, []);

        useEffect(() => {
            if(!textInput) return;
            setLoading(true);
            setTimeout(() => {
                const raw = parseFasta(textInput); 
                setParsedRawData(raw); 
                setLoading(false);
                setMatchResult(null);
                setHighlightedPath(null);
                setZoomToPath(null);
            }, 100);
        }, [textInput]);

        useEffect(() => {
            if (parsedRawData.length === 0) return;

            let dataToBuild = [...parsedRawData];

            if (matchResult && !matchResult.notFound && matchResult.entry) {
                const userEntry = {
                    header: matchResult.userHeader,
                    sequence: querySequence.replace(/^>.*\n/, '').replace(/\s/g, ''), 
                    length: querySequence.replace(/^>.*\n/, '').replace(/\s/g, '').length,
                    taxonomy: [...matchResult.entry.taxonomy, matchResult.userHeader] 
                };
                dataToBuild.push(userEntry);
            }

            const hier = buildHierarchy(dataToBuild, weightBy);
            setParsedData(hier);
        }, [parsedRawData, weightBy, matchResult]);

        const handleFindSimilar = () => {
            if (!querySequence.trim() || parsedRawData.length === 0) return;
            
            setLoading(true);
            setTimeout(() => {
                let bestScore = -1;
                let bestEntry = null;

                let qSeq = querySequence.trim();
                let userHeader = "User Query";
                if (qSeq.startsWith(">")) {
                    const firstLineEnd = qSeq.indexOf('\n');
                    if (firstLineEnd !== -1) {
                        userHeader = qSeq.substring(1, firstLineEnd).trim();
                        qSeq = qSeq.substring(firstLineEnd).trim();
                    }
                }
                
                const qSeqClean = qSeq.replace(/\s/g, '').toUpperCase();
                
                parsedRawData.forEach(entry => {
                    const dbSeq = entry.sequence.toUpperCase();
                    if (dbSeq.length < 6) return;
                    
                    const score = calculateSimilarity(qSeqClean, dbSeq);
                    if (score > bestScore) {
                        bestScore = score;
                        bestEntry = entry;
                    }
                });

                if (bestEntry && bestScore > 0) {
                    setMatchResult({ entry: bestEntry, score: bestScore, userHeader });
                    const newUserPath = [...bestEntry.taxonomy, userHeader];
                    setHighlightedPath(newUserPath);
                    setZoomToPath(null); 
                } else {
                    setMatchResult({ notFound: true, userHeader });
                    setHighlightedPath(null);
                }
                setLoading(false);
            }, 50);
        };

        const handleMatchClick = () => {
            if (matchResult && matchResult.entry) {
                setZoomToPath(matchResult.entry.taxonomy);
            }
        };

        const loadExample = () => setTextInput(exampleData);
        const onFileDrop = (e) => {
            e.preventDefault(); setIsDragging(false);
            const file = e.dataTransfer.files[0];
            if (file) readFile(file);
        };
        const onFileSelect = (e) => {
            if (e.target.files[0]) readFile(e.target.files[0]);
        };
        const readFile = (file) => {
            const reader = new FileReader();
            reader.onload = (e) => setTextInput(e.target.result);
            reader.readAsText(file);
        };

        const handleNodeClick = (nodeData) => {
            if (nodeData.name === "Life") {
                setSelectedNode(null);
            } else {
                setSelectedNode(nodeData);
            }
        };

        return (
            <div className="min-h-screen flex flex-col md:flex-row">
                <div className="w-full md:w-1/3 bg-white border-r border-gray-200 p-6 flex flex-col h-screen overflow-y-auto shadow-lg z-10">
                    <h1 className="text-2xl font-bold text-gray-800 mb-2 flex items-center gap-2">
                        <i data-lucide="dna" className="text-indigo-600"></i>
                        PhyloBurst
                    </h1>
                    <p className="text-sm text-gray-500 mb-6">Smart taxonomy visualization. Automatically detects IDs and Organism names.</p>

                    <div className="space-y-4 flex-1">
                        
                        {/* Sequence Locator */}
                        <div className="bg-indigo-50 p-4 rounded-xl border border-indigo-100 shadow-sm">
                            <h2 className="text-xs font-bold text-indigo-800 uppercase mb-2 flex items-center gap-1">
                                <i data-lucide="crosshair" className="w-3 h-3"></i> Locate Similar Sequence
                            </h2>
                            <textarea 
                                className="w-full h-24 p-2 text-xs font-mono border border-indigo-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none mb-2"
                                placeholder=">Optional Header&#10;Paste DNA sequence here..."
                                value={querySequence}
                                onChange={(e) => setQuerySequence(e.target.value)}
                            ></textarea>
                            <button 
                                onClick={handleFindSimilar}
                                disabled={!querySequence}
                                className="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-indigo-300 text-white font-bold py-2 rounded-lg text-xs transition-colors shadow-sm flex items-center justify-center gap-2"
                            >
                                <i data-lucide="search" className="w-3 h-3"></i> Find Placement in Sunburst
                            </button>
                            
                            {matchResult && !matchResult.notFound && (
                                <div 
                                    onClick={handleMatchClick}
                                    className="mt-3 bg-white p-3 rounded border border-green-200 animate-in fade-in zoom-in duration-300 cursor-pointer hover:bg-green-50 hover:border-green-400 hover:shadow-md transition-all group"
                                    title="Click to zoom into this sequence on the chart"
                                >
                                    <div className="flex items-start gap-2">
                                        <i data-lucide="check-circle" className="w-4 h-4 text-green-500 mt-0.5 group-hover:scale-110 transition-transform"></i>
                                        <div>
                                            <p className="text-xs font-semibold text-gray-700 mb-1">
                                                Matched: <span className="font-bold text-indigo-700 block truncate w-48">{matchResult.userHeader}</span>
                                            </p>
                                            <div className="text-xs text-gray-500 mb-1">
                                                Closest to: <span className="font-mono text-gray-700 truncate w-48 inline-block align-bottom">{matchResult.entry.header.substring(0, 30)}...</span>
                                            </div>
                                            <div className="mt-1 flex gap-2 items-center">
                                                <span className="text-[10px] bg-green-100 text-green-700 px-1.5 py-0.5 rounded font-bold">
                                                    {(matchResult.score * 100).toFixed(1)}% Sim
                                                </span>
                                                <span className="text-[10px] bg-gray-100 text-gray-600 px-1.5 py-0.5 rounded flex items-center gap-1">
                                                    <i data-lucide="zoom-in" className="w-3 h-3"></i> Click to Zoom
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {matchResult && matchResult.notFound && (
                                <div className="mt-3 p-2 text-xs text-red-500 bg-red-50 rounded text-center">
                                    No significant similarity found for "{matchResult.userHeader}".
                                </div>
                            )}
                        </div>

                        <hr className="border-gray-200" />

                        <div 
                            className={`border-2 border-dashed rounded-xl p-6 text-center transition-colors cursor-pointer ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-gray-400'}`}
                            onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                            onDragLeave={() => setIsDragging(false)}
                            onDrop={onFileDrop}
                            onClick={() => document.getElementById('fileInput').click()}
                        >
                            <input type="file" id="fileInput" className="hidden" onChange={onFileSelect} accept=".fasta,.fa,.txt" />
                            <div className="text-gray-400 mb-2 mx-auto"><i data-lucide="upload-cloud" size="32"></i></div>
                            <p className="text-sm font-medium text-gray-600">Drop FASTA Dataset</p>
                        </div>

                        <div>
                            <div className="flex justify-between items-center mb-1">
                                <label className="block text-xs font-semibold text-gray-700 uppercase">Input Dataset</label>
                                <button onClick={loadExample} className="text-xs text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1">
                                    <i data-lucide="refresh-cw" className="w-3 h-3"></i> Load Example
                                </button>
                            </div>
                            <textarea
                                className="w-full h-32 p-3 text-xs font-mono border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
                                value={textInput}
                                onChange={(e) => setTextInput(e.target.value)}
                                placeholder=">Header...&#10;SEQUENCE..."
                            ></textarea>
                        </div>

                        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200 space-y-4">
                            <div>
                                <label className="block text-xs font-semibold text-gray-700 uppercase mb-2">Segment Size By</label>
                                <div className="flex bg-white rounded-md shadow-sm border border-gray-300 overflow-hidden">
                                    <button onClick={() => setWeightBy('count')} className={`flex-1 py-2 text-xs font-medium ${weightBy === 'count' ? 'bg-blue-50 text-blue-600' : 'text-gray-600 hover:bg-gray-50'}`}>Count</button>
                                    <div className="w-px bg-gray-300"></div>
                                    <button onClick={() => setWeightBy('length')} className={`flex-1 py-2 text-xs font-medium ${weightBy === 'length' ? 'bg-blue-50 text-blue-600' : 'text-gray-600 hover:bg-gray-50'}`}>Length</button>
                                </div>
                            </div>
                            
                            <div>
                                <label className="block text-xs font-semibold text-gray-700 uppercase mb-1">Chart Size</label>
                                <div className="flex items-center gap-3">
                                    <input 
                                        type="range" min="20" max="200" step="10"
                                        value={chartSize} 
                                        onChange={(e) => setChartSize(Number(e.target.value))}
                                        className="w-full accent-indigo-600"
                                    />
                                    <span className="text-sm font-bold w-8 text-right">{chartSize}%</span>
                                </div>
                            </div>
                        </div>

                        <button onClick={() => setTextInput(textInput + " ")} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg shadow-md transition-all active:scale-95">
                            {loading ? 'Processing...' : 'Visualize Taxonomy'}
                        </button>
                    </div>
                </div>

                {/* Main Viz Area */}
                <div className="flex-1 bg-gray-100 flex flex-col h-screen overflow-hidden">
                    
                    <div className="flex-1 flex items-center justify-center p-4 relative overflow-hidden bg-white/50">
                         <div className="absolute top-4 right-4 bg-white/90 backdrop-blur px-4 py-2 rounded-lg text-xs text-gray-500 shadow-sm border border-gray-200 z-20">
                            <p className="font-semibold mb-1">Ring Levels:</p>
                            <ol className="list-decimal list-inside space-y-0.5">
                                <li>Kingdom</li>
                                <li>Phylum</li>
                                <li>Family</li>
                                <li>Genus / Species</li>
                                <li>User Matches</li>
                            </ol>
                        </div>

                        {parsedData && parsedData.children.length > 0 ? (
                            <Sunburst 
                                data={parsedData} 
                                scale={chartSize}
                                onNodeClick={handleNodeClick} 
                                highlightedPath={highlightedPath} 
                                zoomToPath={zoomToPath}
                            />
                        ) : (
                            <div className="text-center text-gray-400">
                                <p className="text-lg">No valid data found.</p>
                                <p className="text-sm">Check your input format.</p>
                            </div>
                        )}
                    </div>

                    {selectedNode && (
                        <div className="h-1/3 bg-white border-t border-gray-200 shadow-xl flex flex-col z-30 transition-all duration-300 ease-in-out">
                            <div className="px-6 py-3 border-b border-gray-100 bg-gray-50 flex justify-between items-center">
                                <div>
                                    <h3 className="font-bold text-gray-800 flex items-center gap-2">
                                        <i data-lucide="list" className="w-4 h-4 text-indigo-500"></i>
                                        Sequences in <span className="text-indigo-600">{selectedNode.name}</span>
                                    </h3>
                                    <p className="text-xs text-gray-500">
                                        Found {selectedNode.entries ? selectedNode.entries.length : 0} sequences
                                    </p>
                                </div>
                                <button onClick={() => setSelectedNode(null)} className="text-gray-400 hover:text-red-500">
                                    <i data-lucide="x" className="w-5 h-5"></i>
                                </button>
                            </div>
                            
                            <div className="flex-1 overflow-auto custom-scroll p-0">
                                <table className="w-full text-left border-collapse">
                                    <thead className="bg-gray-100 sticky top-0 z-10">
                                        <tr>
                                            <th className="px-6 py-2 text-xs font-semibold text-gray-600 uppercase tracking-wider">Header / Description</th>
                                            <th className="px-6 py-2 text-xs font-semibold text-gray-600 uppercase tracking-wider text-right">Length (bp)</th>
                                            <th className="px-6 py-2 text-xs font-semibold text-gray-600 uppercase tracking-wider">Kingdom</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-100">
                                        {selectedNode.entries && selectedNode.entries.map((entry, idx) => (
                                            <tr key={idx} className="hover:bg-indigo-50 transition-colors text-xs text-gray-700">
                                                <td className="px-6 py-2 font-mono truncate max-w-md" title={entry.header}>
                                                    {entry.header}
                                                </td>
                                                <td className="px-6 py-2 text-right font-mono text-gray-500">
                                                    {entry.length.toLocaleString()}
                                                </td>
                                                <td className="px-6 py-2">
                                                    <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-800">
                                                        {entry.taxonomy[0] || "Unknown"}
                                                    </span>
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    lucide.createIcons();
</script>
</body>
</html>
